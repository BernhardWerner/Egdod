<!DOCTYPE html>
<html lang="en">
 <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <title>Egdod test</title>
    <script type="text/javascript" src="https://cindyjs.org/dist/v0.8/Cindy.js"></script>
    <script type="text/javascript" src="https://cindyjs.org/dist/v0.8/CindyGL.js"></script>
    <script type="text/javascript" src="https://cindyjs.org/dist/v0.8/Cindy3D.js"></script>
    <script type="text/javascript" src="cindyLoader.js"></script>

  </head>

<body style="font-family:Palatino; margin:0; font-size:16pt">



<script id='csinit' type='text/x-cindyscript'>
updateGradients() := (
  gradients = [
    apply(1..resolution, lerp(colorA, colorB, #, 1, resolution) ),
    apply(1..resolution, hsv2rgb( lerpHSV(rgb2hsv(colorA), rgb2hsv(colorB), inverseLerp(1, resolution, #)) ) ),
    apply(1..resolution, lch2rgb( lerpLCH(rgb2lch(colorA), rgb2lch(colorB), inverseLerp(1, resolution, #)) ) )
  ];
);

resetColors() := (
  colorA = [random(), random(), random()];
  colorB = [random(), random(), random()];

  updateGradients();

);


resolution = 300;

colorA = sapColor.blue;
colorB = sapColor.orange;

updateGradients();



camDist3D = 3.1;
camPolar3D = pi / 4;
camAzimuth3D = -pi * 0.6;

lookAt3D = 0.5 * [1,1,1];

camera3D() := camDist3D * [cos(camAzimuth3D) * sin(camPolar3D), sin(camAzimuth3D) * sin(camPolar3D), cos(camPolar3D)] + lookAt3D;

fov = 20°;

getDist() := javascript("currDist = " + camDist3D + ";");
getAzimuth() := javascript("currAzimuth = " + camAzimuth3D + ";");
getPolar() := javascript("currPolar = " + camPolar3D + ";");

getLookAt() := javascript("currLookAt = " + lookAt3D + ";");
getCamAxes() := javascript("currCamAxes = " + computeCamAxes() + ";");

computeCamAxes() := (
  regional(backward, right, up);

  backward = camera3D() - lookAt3D;
  backward = backward / abs(backward);

  right = cross([0,0,1], backward);
  right = right / abs(right);

  up = cross(backward, right);

  [right, up, backward];
);



pressSpace() := (
  resetColors();

);


inputBuffer = {
  "w": 0,
  "s": 0,
  "a": 0,
  "d": 0,
  "q": 0,
  "e": 0
};

moveSpeed = 0.03 * 60;  
move(del) := (
  regional(input);

  input = [
    inputBuffer.d - inputBuffer.a, 
    inputBuffer.e - inputBuffer.q,
    inputBuffer.s - inputBuffer.w
  ];

  if(input != [0,0,0], input = input / abs(input));
  lookAt3D = lookAt3D + transpose(computeCamAxes()) * input * moveSpeed * del;
);



cameraMatrix() := (
  regional(cc, m1, m2);

  cc = computeCamAxes();
  
  m1 = linearsolve([lookAt3D - camera3D(), cc.x, cc.y], [0,1,0]);
  m2 = linearsolve([lookAt3D - camera3D(), cc.x, cc.y], [0,0,1]);

  [m1, m2] * focalLength(fov) * 0.0628;
);



drawLabels() := (
  draw(cameraMatrix() * (colorA - camera3D()) + canvasCenter, color -> (1,1,1));
  drawtext(cameraMatrix() * (colorA - camera3D()) + canvasCenter, "sRGB", align -> "mid", color -> (1,1,1));
);







focalLength(phi) := canvasWidth / tan(phi / 2); 








setupTime();
playanimation();


</script>



<script id='csdraw' type='text/x-cindyscript'>
  cc = computeCamAxes();

  begin3d();
    background3d(sapColor.background);

    renderhints3d(quality -> 8, renderMode -> "raycasted", samplingRate -> 4);
    lookat3d(camera3D(), lookAt3D, [0, 0, 1]);
    fieldofview3d(fov);
    directionallight3d(1, direction -> [1,1,1], diffuse -> (1,1,1) * 0.5, frame -> "camera");
    shininess3d(2);
    depthrange3d(0.2, 300);

    
    draw3d([1,1,1], [1,1,0], color -> toolColor("grey"), size -> 0.2);
    draw3d([1,1,1], [1,0,1], color -> toolColor("grey"), size -> 0.2);
    draw3d([1,1,1], [0,1,1], color -> toolColor("grey"), size -> 0.2);
    
    draw3d([0,0,1], [0,1,1], color -> toolColor("grey"), size -> 0.2);
    draw3d([0,1,0], [0,1,1], color -> toolColor("grey"), size -> 0.2);
    draw3d([1,0,0], [1,0,1], color -> toolColor("grey"), size -> 0.2);
    draw3d([0,0,1], [1,0,1], color -> toolColor("grey"), size -> 0.2);
    draw3d([0,1,0], [1,1,0], color -> toolColor("grey"), size -> 0.2);
    draw3d([1,0,0], [1,1,0], color -> toolColor("grey"), size -> 0.2);

    forall(gradients, grad,
      forall(1..resolution - 1, index,
        draw3d(grad_index, grad_(index + 1), size -> 0.2, color -> lerp(grad_index, grad_(index + 1), 0.5));
      );
    );

    drawsphere3d(colorA, 0.04, color -> colorA);
    drawsphere3d(colorB, 0.04, color -> colorB);
    
    drawsphere3d(lookAt3D, 0.04, color -> colorB);

    drawAxes3D(-0.2, 1.2, 0.2, 0.1, 0.05);
  end3d();

  drawLabels();


</script>



<script id='cstick' type='text/x-cindyscript'>
delta = deltaTime();

move(delta);
</script>


<script id='csmousemove' type='text/x-cindyscript'>


</script>

<script id='csmousedown' type='text/x-cindyscript'>
</script>

<script id='csmousedrag' type='text/x-cindyscript'>
</script>

<script id='csmouseup' type='text/x-cindyscript'>
</script>

<!-- <script id='cskeydown' type='text/x-cindyscript'>
</script> -->


<div id="container" style="position: relative;">
  <canvas id="Cindy3D" width="800" height="600" style="position: absolute; top: 0px; left: 0px; border:0px solid #ADADAD;"></canvas>
  <canvas id="CSCanvas" width="800" height="600" style="position: absolute; top: 0; left: 0; border:0px solid #000000;"></canvas>
  <canvas id="CameraController" width="800" height="600" style="position: absolute; top: 0px; left: 0px; border:0px solid #ADADAD;"></canvas>
</div>






<script>
  fetch("egdod.cjs")
  .then(response => response.text())
  .then(data => {
    loadCindyScript(data);
    cindy = createCindy({canvasname:"CSCanvas",
      scripts:"cs*",
      images: {
      },
      use:["katex", "Cindy3D"]
    });
  });
</script>






<script>


  document.onkeydown = function(event){


    if(!is3d) return;
    switch(event.key) {
      case "w": cindy.evokeCS("inputBuffer.w = 1;"); break;
      case "s": cindy.evokeCS("inputBuffer.s = 1;"); break;
      case "a": cindy.evokeCS("inputBuffer.a = 1;"); break;
      case "d": cindy.evokeCS("inputBuffer.d = 1;"); break;
      case "q": cindy.evokeCS("inputBuffer.q = 1;"); break;
      case "e": cindy.evokeCS("inputBuffer.e = 1;"); break;
      case "f": cindy.evokeCS("lookAt3D = 0.5 * [1,1,1];"); break;
      case " ": cindy.evokeCS("pressSpace();"); break;
    }
  }

  document.onkeyup = function(event){


    if(!is3d) return;

    switch(event.key) {
      case "w": cindy.evokeCS("inputBuffer.w = 0;"); break;
      case "s": cindy.evokeCS("inputBuffer.s = 0;"); break;
      case "a": cindy.evokeCS("inputBuffer.a = 0;"); break;
      case "d": cindy.evokeCS("inputBuffer.d = 0;"); break;
      case "q": cindy.evokeCS("inputBuffer.q = 0;"); break;
      case "e": cindy.evokeCS("inputBuffer.e = 0;"); break;
    }
  }

   

  // Camera controls. Currently no touch support
  controller = document.getElementById("CameraController");

  let currAzimuth, currPolar, currDist, mouseIsDown, currMouse, currLookAt, currCamAxes;
  let is3d = true;
  

  function getMousePos(canvas, evt) {
    var rect = canvas.getBoundingClientRect();
    return [evt.clientX - rect.left, evt.clientY - rect.top]
  }


  controller.onmousedown = function(event){
    mouseIsDown = true;
    currMouse = getMousePos(controller, event);
    cindy.evokeCS("getAzimuth();");
    cindy.evokeCS("getPolar();");

  }

  controller.onmousemove = function(event){
    if(!mouseIsDown) return;
    if(!is3d) return;

    let relMouse = getMousePos(controller, event);
    relMouse[0] -= currMouse[0];
    relMouse[1] -= currMouse[1];


    // cindy.evokeCS("camDist3D = " + (currDist - 0.01 * relMouse[0]) + ";");

    cindy.evokeCS("camAzimuth3D = mod(" + (currAzimuth - 0.01 * relMouse[0]) + ", 2 * pi);");
    cindy.evokeCS("camPolar3D = clamp(" + (currPolar - 0.01 * relMouse[1]) + ", 0.001 * pi, 0.999 * pi);");

  }

  controller.onmouseup = function(event){
    mouseIsDown = false;
  }



  controller.onwheel = function(event){
    if(!is3d) return;

    cindy.evokeCS("camDist3D = camDist3D * " + Math.pow(2, 0.003 * event.deltaY) + ";");
  }









</script>




</body>

</html>

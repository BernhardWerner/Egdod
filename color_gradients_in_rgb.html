<!DOCTYPE html>
<html lang="en">
 <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <title>Egdod test</title>
    <script type="text/javascript" src="https://cindyjs.org/dist/v0.8/Cindy.js"></script>
    <script type="text/javascript" src="https://cindyjs.org/dist/v0.8/CindyGL.js"></script>
    <script type="text/javascript" src="https://cindyjs.org/dist/v0.8/Cindy3D.js"></script>
    <script type="text/javascript" src="cindyLoader.js"></script>

  </head>

<body style="font-family:Palatino; margin:0; font-size:16pt">



<script id='csinit' type='text/x-cindyscript'>
updateGradients() := (
  gradients = [
    apply(1..resolution, lerp(colorA, colorB, #, 1, resolution) ),
    apply(1..resolution, hsv2rgb( lerpHSV(rgb2hsv(colorA), rgb2hsv(colorB), inverseLerp(1, resolution, #)) ) ),
    apply(1..resolution, lch2rgb( lerpLCH(rgb2lch(colorA), rgb2lch(colorB), inverseLerp(1, resolution, #)) ) )
  ];
);

resetColors() := (
  colorA = [random(), random(), random()];
  colorB = [random(), random(), random()];

  updateGradients();

);


resolution = 256;

colorA = sapColor.blue;
colorB = sapColor.orange;

updateGradients();



camDist3D = 3.1;
camPolar3D = pi / 4;
camAzimuth3D = -pi * 0.6;

lookAt3D = 0.5 * [1,1,1];

camera3D() := camDist3D * [cos(camAzimuth3D) * sin(camPolar3D), sin(camAzimuth3D) * sin(camPolar3D), cos(camPolar3D)] + lookAt3D;

fov = 20°;

getDist() := javascript("currDist = " + camDist3D + ";");
getAzimuth() := javascript("currAzimuth = " + camAzimuth3D + ";");
getPolar() := javascript("currPolar = " + camPolar3D + ";");

getLookAt() := javascript("currLookAt = " + lookAt3D + ";");
getCamAxes() := javascript("currCamAxes = " + computeCamAxes() + ";");

computeCamAxes() := (
  regional(backward, right, up);

  backward = camera3D() - lookAt3D;
  backward = backward / abs(backward);

  right = cross([0,0,1], backward);
  right = right / abs(right);

  up = cross(backward, right);

  [right, up, backward];
);



pressSpace() := (
  resetColors();

);


inputBuffer = {
  "w": 0,
  "s": 0,
  "a": 0,
  "d": 0,
  "q": 0,
  "e": 0
};

moveSpeed = 0.03 * 60;  
move(del) := (
  regional(input);

  input = [
    inputBuffer.d - inputBuffer.a, 
    inputBuffer.e - inputBuffer.q,
    inputBuffer.s - inputBuffer.w
  ];

  if(input != [0,0,0], input = input / abs(input));
  lookAt3D = lookAt3D + transpose(computeCamAxes()) * input * moveSpeed * del;
);



cameraMatrix() := (
  regional(cc, m1, m2);

  cc = computeCamAxes();
  
  m1 = linearsolve([lookAt3D - camera3D(), cc.x, cc.y], [0,1,0]);
  m2 = linearsolve([lookAt3D - camera3D(), cc.x, cc.y], [0,0,1]);

  [m1, m2] * focalLength(fov) * 0.0628;
);


projectTo2D(p) := (
  regional(cc);

  cc = computeCamAxes();

  33 * tan(20°) / tan(fov) * [cc.x, cc.y] * centralProjToOrthoPlane(cc.z, p - camera3D() + cc.z) + canvasCenter;
);



drawLabel(index) := (
  drawtext(projectTo2D( anchor(index) ) + [0.1, 0.1], labels_index, size -> 1.2 * max(25 - 3 * dist(camera3D(), anchor(index)), 0), align -> "left", color -> (1,1,1));
);


anchor(index) := gradients_index_(round(0.5 * resolution));


drawAllLables() := (
  drawOrder = sort(1..3, -dist(camera3D(), anchor(#)) );

  forall(drawOrder,
    clearimage("outlineBuffer");
    canvas(canvasCorners.bl, canvasCorners.br, "outlineBuffer",
      drawLabel(#);
    );

    drawOutline("outlineBuffer", 0.1, sapColor.background);
    drawLabel(#);
  );
);


labels = ["sRGB", "HSV", "Lch"];









createimage("outlineBuffer", 800, 600);








setupTime();
playanimation();


</script>



<script id='csdraw' type='text/x-cindyscript'>
  begin3d();
    background3d(sapColor.background);

    renderhints3d(quality -> 8, renderMode -> "raycasted", samplingRate -> 4);
    lookat3d(camera3D(), lookAt3D, [0, 0, 1]);
    fieldofview3d(fov);
    directionallight3d(1, direction -> [1,1,1], diffuse -> (1,1,1) * 0.5, frame -> "camera");
    shininess3d(2);
    depthrange3d(0.2, 300);

    

    end = 1.2;
    arrowHeadLength = 0.1;
    arrowHeadRadius = 0.04;
    drawCone3D([end - 0.5 * arrowHeadLength, 0, 0], arrowHeadRadius, [end + 0.5 * arrowHeadLength, 0, 0], [1,0,0]);
    drawCone3D([0, end - 0.5 * arrowHeadLength, 0], arrowHeadRadius, [0, end + 0.5 * arrowHeadLength, 0], [0,1,0]);
    drawCone3D([0, 0, end - 0.5 * arrowHeadLength], arrowHeadRadius, [0, 0, end + 0.5 * arrowHeadLength], [0,0,1]);
    boxSize = 0.15;
    boxResolution = 40;
    gradientSize = 0.4;


    forall(1..boxResolution - 1, index,
      draw3d([1,0,0] * inverseLerp(1, boxResolution, index), [1,0,0] * (inverseLerp(1, boxResolution, index) + 1/boxResolution), size -> boxSize, color -> [1,0,0] * (inverseLerp(1, boxResolution, index) + 0.5/boxResolution));
      draw3d([0,1,0] + [1,0,0] * inverseLerp(1, boxResolution, index), [0,1,0] + [1,0,0] * (inverseLerp(1, boxResolution, index) + 1/boxResolution), size -> boxSize, color -> [0,1,0] + [1,0,0] * (inverseLerp(1, boxResolution, index) + 0.5/boxResolution));
      draw3d([0,0,1] + [1,0,0] * inverseLerp(1, boxResolution, index), [0,0,1] + [1,0,0] * (inverseLerp(1, boxResolution, index) + 1/boxResolution), size -> boxSize, color -> [0,0,1] + [1,0,0] * (inverseLerp(1, boxResolution, index) + 0.5/boxResolution));
      draw3d([0,1,1] + [1,0,0] * inverseLerp(1, boxResolution, index), [0,1,1] + [1,0,0] * (inverseLerp(1, boxResolution, index) + 1/boxResolution), size -> boxSize, color -> [0,1,1] + [1,0,0] * (inverseLerp(1, boxResolution, index) + 0.5/boxResolution));
        
      draw3d([0,1,0] * inverseLerp(1, boxResolution, index), [0,1,0] * (inverseLerp(1, boxResolution, index) + 1/boxResolution), size -> boxSize, color -> [0,1,0] * (inverseLerp(1, boxResolution, index) + 0.5/boxResolution));
      draw3d([1,0,0] + [0,1,0] * inverseLerp(1, boxResolution, index), [1,0,0] + [0,1,0] * (inverseLerp(1, boxResolution, index) + 1/boxResolution), size -> boxSize, color -> [1,0,0] + [0,1,0] * (inverseLerp(1, boxResolution, index) + 0.5/boxResolution));
      draw3d([0,0,1] + [0,1,0] * inverseLerp(1, boxResolution, index), [0,0,1] + [0,1,0] * (inverseLerp(1, boxResolution, index) + 1/boxResolution), size -> boxSize, color -> [0,0,1] + [0,1,0] * (inverseLerp(1, boxResolution, index) + 0.5/boxResolution));
      draw3d([1,0,1] + [0,1,0] * inverseLerp(1, boxResolution, index), [1,0,1] + [0,1,0] * (inverseLerp(1, boxResolution, index) + 1/boxResolution), size -> boxSize, color -> [1,0,1] + [0,1,0] * (inverseLerp(1, boxResolution, index) + 0.5/boxResolution));
      
      draw3d([0,0,1] * inverseLerp(1, boxResolution, index), [0,0,1] * (inverseLerp(1, boxResolution, index) + 1/boxResolution), size -> boxSize, color -> [0,0,1] * (inverseLerp(1, boxResolution, index) + 0.5/boxResolution));        
      draw3d([1,0,0] + [0,0,1] * inverseLerp(1, boxResolution, index), [1,0,0] + [0,0,1] * (inverseLerp(1, boxResolution, index) + 1/boxResolution), size -> boxSize, color -> [1,0,0] + [0,0,1] * (inverseLerp(1, boxResolution, index) + 0.5/boxResolution));
      draw3d([0,1,0] + [0,0,1] * inverseLerp(1, boxResolution, index), [0,1,0] + [0,0,1] * (inverseLerp(1, boxResolution, index) + 1/boxResolution), size -> boxSize, color -> [0,1,0] + [0,0,1] * (inverseLerp(1, boxResolution, index) + 0.5/boxResolution));
      draw3d([1,1,0] + [0,0,1] * inverseLerp(1, boxResolution, index), [1,1,0] + [0,0,1] * (inverseLerp(1, boxResolution, index) + 1/boxResolution), size -> boxSize, color -> [1,1,0] + [0,0,1] * (inverseLerp(1, boxResolution, index) + 0.5/boxResolution));
    );
    draw3d([0,0,0], [-0.2,0,0], size -> boxSize, color -> [0,0,0]);
    draw3d([0,0,0], [0,-0.2,0], size -> boxSize, color -> [0,0,0]);
    draw3d([0,0,0], [0,0,-0.2], size -> boxSize, color -> [0,0,0]);
    
    draw3d([1,0,0], [1.2,0,0], size -> boxSize, color -> [1,0,0]);
    draw3d([0,1,0], [0,1.2,0], size -> boxSize, color -> [0,1,0]);
    draw3d([0,0,1], [0,0,1.2], size -> boxSize, color -> [0,0,1]);

    forall(gradients, grad,
      forall(1..resolution - 1, index,
        draw3d(grad_index, grad_(index + 1), size -> gradientSize, color -> lerp(grad_index, grad_(index + 1), 0.5));
      );
    );

    drawsphere3d(colorA, 0.04, color -> colorA);
    drawsphere3d(colorB, 0.04, color -> colorB);
    

    end3d();

drawAllLables();

</script>



<script id='cstick' type='text/x-cindyscript'>
delta = deltaTime();

move(delta);
</script>


<script id='csmousemove' type='text/x-cindyscript'>


</script>

<script id='csmousedown' type='text/x-cindyscript'>
</script>

<script id='csmousedrag' type='text/x-cindyscript'>
</script>

<script id='csmouseup' type='text/x-cindyscript'>
</script>

<!-- <script id='cskeydown' type='text/x-cindyscript'>
</script> -->


<div id="container" style="position: relative;">
  <canvas id="Cindy3D" width="800" height="600" style="position: absolute; top: 0px; left: 0px; border:0px solid #ADADAD;"></canvas>
  <canvas id="CSCanvas" width="800" height="600" style="position: absolute; top: 0; left: 0; border:0px solid #000000;"></canvas>
  <canvas id="CameraController" width="800" height="600" style="position: absolute; top: 0px; left: 0px; border:0px solid #ADADAD;"></canvas>
</div>






<script>
  fetch("egdod.cjs")
  .then(response => response.text())
  .then(data => {
    loadCindyScript(data);
    cindy = createCindy({canvasname:"CSCanvas",
      scripts:"cs*",
      images: {
      },
      use:["Cindy3D"]
    });
  });
</script>






<script>


  document.onkeydown = function(event){


    if(!is3d) return;
    switch(event.key) {
      case "w": cindy.evokeCS("inputBuffer.w = 1;"); break;
      case "s": cindy.evokeCS("inputBuffer.s = 1;"); break;
      case "a": cindy.evokeCS("inputBuffer.a = 1;"); break;
      case "d": cindy.evokeCS("inputBuffer.d = 1;"); break;
      case "q": cindy.evokeCS("inputBuffer.q = 1;"); break;
      case "e": cindy.evokeCS("inputBuffer.e = 1;"); break;
      case "f": cindy.evokeCS("lookAt3D = 0.5 * [1,1,1];"); break;
      case " ": cindy.evokeCS("pressSpace();"); break;
    }
  }

  document.onkeyup = function(event){


    if(!is3d) return;

    switch(event.key) {
      case "w": cindy.evokeCS("inputBuffer.w = 0;"); break;
      case "s": cindy.evokeCS("inputBuffer.s = 0;"); break;
      case "a": cindy.evokeCS("inputBuffer.a = 0;"); break;
      case "d": cindy.evokeCS("inputBuffer.d = 0;"); break;
      case "q": cindy.evokeCS("inputBuffer.q = 0;"); break;
      case "e": cindy.evokeCS("inputBuffer.e = 0;"); break;
    }
  }

   

  // Camera controls. Currently no touch support
  controller = document.getElementById("CameraController");

  let currAzimuth, currPolar, currDist, mouseIsDown, currMouse, currLookAt, currCamAxes;
  let is3d = true;
  

  function getMousePos(canvas, evt) {
    var rect = canvas.getBoundingClientRect();
    return [evt.clientX - rect.left, evt.clientY - rect.top]
  }


  controller.onmousedown = function(event){
    mouseIsDown = true;
    currMouse = getMousePos(controller, event);
    cindy.evokeCS("getAzimuth();");
    cindy.evokeCS("getPolar();");

  }

  controller.onmousemove = function(event){
    if(!mouseIsDown) return;
    if(!is3d) return;

    let relMouse = getMousePos(controller, event);
    relMouse[0] -= currMouse[0];
    relMouse[1] -= currMouse[1];


    // cindy.evokeCS("camDist3D = " + (currDist - 0.01 * relMouse[0]) + ";");

    cindy.evokeCS("camAzimuth3D = mod(" + (currAzimuth - 0.01 * relMouse[0]) + ", 2 * pi);");
    cindy.evokeCS("camPolar3D = clamp(" + (currPolar - 0.01 * relMouse[1]) + ", 0.001 * pi, 0.999 * pi);");

  }

  controller.onmouseup = function(event){
    mouseIsDown = false;
  }



  controller.onwheel = function(event){
    if(!is3d) return;

    cindy.evokeCS("camDist3D = camDist3D * " + Math.pow(2, 0.003 * event.deltaY) + ";");
  }









</script>




</body>

</html>
